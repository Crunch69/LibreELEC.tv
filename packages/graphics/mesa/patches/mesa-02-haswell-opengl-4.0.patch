diff --git a/src/mesa/drivers/dri/i965/genX_blorp_exec.c b/src/mesa/drivers/dri/i965/genX_blorp_exec.c
index edcd896..40a2499 100644
--- a/src/mesa/drivers/dri/i965/genX_blorp_exec.c
+++ b/src/mesa/drivers/dri/i965/genX_blorp_exec.c
@@ -55,12 +55,12 @@ blorp_emit_reloc(struct blorp_batch *batch,
 
    uint32_t offset = (char *)location - (char *)brw->batch.map;
    if (brw->gen >= 8) {
-      return intel_batchbuffer_reloc64(brw, address.buffer, offset,
+      return intel_batchbuffer_reloc64(&brw->batch, address.buffer, offset,
                                        address.read_domains,
                                        address.write_domain,
                                        address.offset + delta);
    } else {
-      return intel_batchbuffer_reloc(brw, address.buffer, offset,
+      return intel_batchbuffer_reloc(&brw->batch, address.buffer, offset,
                                      address.read_domains,
                                      address.write_domain,
                                      address.offset + delta);
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.c b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
index f136fae..f45ef03 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.c
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
@@ -439,14 +439,14 @@ _intel_batchbuffer_flush(struct brw_context *brw,
 /*  This is the only way buffers get added to the validate list.
  */
 uint32_t
-intel_batchbuffer_reloc(struct brw_context *brw,
+intel_batchbuffer_reloc(struct intel_batchbuffer *batch,
                         drm_intel_bo *buffer, uint32_t offset,
                         uint32_t read_domains, uint32_t write_domain,
                         uint32_t delta)
 {
    int ret;
 
-   ret = drm_intel_bo_emit_reloc(brw->batch.bo, offset,
+   ret = drm_intel_bo_emit_reloc(batch->bo, offset,
 				 buffer, delta,
 				 read_domains, write_domain);
    assert(ret == 0);
@@ -460,12 +460,12 @@ intel_batchbuffer_reloc(struct brw_context *brw,
 }
 
 uint64_t
-intel_batchbuffer_reloc64(struct brw_context *brw,
+intel_batchbuffer_reloc64(struct intel_batchbuffer *batch,
                           drm_intel_bo *buffer, uint32_t offset,
                           uint32_t read_domains, uint32_t write_domain,
                           uint32_t delta)
 {
-   int ret = drm_intel_bo_emit_reloc(brw->batch.bo, offset,
+   int ret = drm_intel_bo_emit_reloc(batch->bo, offset,
                                      buffer, delta,
                                      read_domains, write_domain);
    assert(ret == 0);
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.h b/src/mesa/drivers/dri/i965/intel_batchbuffer.h
index fbb5158..c4573ec 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.h
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.h
@@ -62,13 +62,13 @@ void intel_batchbuffer_data(struct brw_context *brw,
                             const void *data, GLuint bytes,
                             enum brw_gpu_ring ring);
 
-uint32_t intel_batchbuffer_reloc(struct brw_context *brw,
+uint32_t intel_batchbuffer_reloc(struct intel_batchbuffer *batch,
                                  drm_intel_bo *buffer,
                                  uint32_t offset,
                                  uint32_t read_domains,
                                  uint32_t write_domain,
                                  uint32_t delta);
-uint64_t intel_batchbuffer_reloc64(struct brw_context *brw,
+uint64_t intel_batchbuffer_reloc64(struct intel_batchbuffer *batch,
                                    drm_intel_bo *buffer,
                                    uint32_t offset,
                                    uint32_t read_domains,
@@ -159,18 +159,18 @@ intel_batchbuffer_advance(struct brw_context *brw)
 #define OUT_BATCH(d) *__map++ = (d)
 #define OUT_BATCH_F(f) OUT_BATCH(float_as_int((f)))
 
-#define OUT_RELOC(buf, read_domains, write_domain, delta) do { \
-   uint32_t __offset = (__map - brw->batch.map) * 4;           \
-   OUT_BATCH(intel_batchbuffer_reloc(brw, (buf), __offset,     \
-                                     (read_domains),           \
-                                     (write_domain),           \
-                                     (delta)));                \
+#define OUT_RELOC(buf, read_domains, write_domain, delta) do {    \
+   uint32_t __offset = (__map - brw->batch.map) * 4;              \
+   OUT_BATCH(intel_batchbuffer_reloc(&brw->batch, (buf), __offset, \
+                                     (read_domains),              \
+                                     (write_domain),              \
+                                     (delta)));                   \
 } while (0)
 
 /* Handle 48-bit address relocations for Gen8+ */
 #define OUT_RELOC64(buf, read_domains, write_domain, delta) do {      \
    uint32_t __offset = (__map - brw->batch.map) * 4;                  \
-   uint64_t reloc64 = intel_batchbuffer_reloc64(brw, (buf), __offset, \
+   uint64_t reloc64 = intel_batchbuffer_reloc64(&brw->batch, (buf), __offset, \
                                                 (read_domains),       \
                                                 (write_domain),       \
                                                 (delta));             \
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.c b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
index f45ef03..75e2fb3 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.c
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
@@ -119,7 +119,7 @@ intel_batchbuffer_require_space(struct brw_context *brw, GLuint sz,
 #ifdef DEBUG
    assert(sz < BATCH_SZ - BATCH_RESERVED);
 #endif
-   if (intel_batchbuffer_space(brw) < sz)
+   if (intel_batchbuffer_space(&brw->batch) < sz)
       intel_batchbuffer_flush(brw);
 
    enum brw_gpu_ring prev_ring = brw->batch.ring;
@@ -408,10 +408,10 @@ _intel_batchbuffer_flush(struct brw_context *brw,
    brw_finish_batch(brw);
 
    /* Mark the end of the buffer. */
-   intel_batchbuffer_emit_dword(brw, MI_BATCH_BUFFER_END);
+   intel_batchbuffer_emit_dword(&brw->batch, MI_BATCH_BUFFER_END);
    if (USED_BATCH(brw->batch) & 1) {
       /* Round batchbuffer usage to 2 DWORDs. */
-      intel_batchbuffer_emit_dword(brw, MI_NOOP);
+      intel_batchbuffer_emit_dword(&brw->batch, MI_NOOP);
    }
 
    intel_upload_finish(brw);
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.h b/src/mesa/drivers/dri/i965/intel_batchbuffer.h
index c4573ec..aca8fa1 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.h
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.h
@@ -94,27 +94,27 @@ static inline uint32_t float_as_int(float f)
  * work...
  */
 static inline unsigned
-intel_batchbuffer_space(struct brw_context *brw)
+intel_batchbuffer_space(struct intel_batchbuffer *batch)
 {
-   return (brw->batch.state_batch_offset - brw->batch.reserved_space)
-      - USED_BATCH(brw->batch) * 4;
+   return (batch->state_batch_offset - batch->reserved_space)
+      - USED_BATCH(*batch) * 4;
 }
 
 
 static inline void
-intel_batchbuffer_emit_dword(struct brw_context *brw, GLuint dword)
+intel_batchbuffer_emit_dword(struct intel_batchbuffer *batch, GLuint dword)
 {
 #ifdef DEBUG
-   assert(intel_batchbuffer_space(brw) >= 4);
+   assert(intel_batchbuffer_space(batch) >= 4);
 #endif
-   *brw->batch.map_next++ = dword;
-   assert(brw->batch.ring != UNKNOWN_RING);
+   *batch->map_next++ = dword;
+   assert(batch->ring != UNKNOWN_RING);
 }
 
 static inline void
-intel_batchbuffer_emit_float(struct brw_context *brw, float f)
+intel_batchbuffer_emit_float(struct intel_batchbuffer *batch, float f)
 {
-   intel_batchbuffer_emit_dword(brw, float_as_int(f));
+   intel_batchbuffer_emit_dword(batch, float_as_int(f));
 }
 
 static inline void
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 4ca77c7..397ae2f 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -1203,7 +1203,7 @@ intelDestroyContext(__DRIcontext * driContextPriv)
       _swrast_DestroyContext(&brw->ctx);
 
    brw_fini_pipe_control(brw);
-   intel_batchbuffer_free(brw);
+   intel_batchbuffer_free(&brw->batch);
 
    drm_intel_bo_unreference(brw->throttle_batch[1]);
    drm_intel_bo_unreference(brw->throttle_batch[0]);
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.c b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
index 75e2fb3..3a26419 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.c
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
@@ -99,11 +99,11 @@ intel_batchbuffer_reset_to_saved(struct brw_context *brw)
 }
 
 void
-intel_batchbuffer_free(struct brw_context *brw)
+intel_batchbuffer_free(struct intel_batchbuffer *batch)
 {
-   free(brw->batch.cpu_map);
-   drm_intel_bo_unreference(brw->batch.last_bo);
-   drm_intel_bo_unreference(brw->batch.bo);
+   free(batch->cpu_map);
+   drm_intel_bo_unreference(batch->last_bo);
+   drm_intel_bo_unreference(batch->bo);
 }
 
 void
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.h b/src/mesa/drivers/dri/i965/intel_batchbuffer.h
index aca8fa1..d0ddf75 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.h
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.h
@@ -40,7 +40,7 @@ struct intel_batchbuffer;
 
 void intel_batchbuffer_emit_render_ring_prelude(struct brw_context *brw);
 void intel_batchbuffer_init(struct brw_context *brw);
-void intel_batchbuffer_free(struct brw_context *brw);
+void intel_batchbuffer_free(struct intel_batchbuffer *batch);
 void intel_batchbuffer_save_state(struct brw_context *brw);
 void intel_batchbuffer_reset_to_saved(struct brw_context *brw);
 void intel_batchbuffer_require_space(struct brw_context *brw, GLuint sz,
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 397ae2f..c1b943e 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -1060,7 +1060,7 @@ brwCreateContext(gl_api api,
 
    intel_fbo_init(brw);
 
-   intel_batchbuffer_init(brw);
+   intel_batchbuffer_init(&brw->batch, brw->bufmgr, brw->has_llc);
 
    if (brw->gen >= 6) {
       /* Create a new hardware context.  Using a hardware context means that
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.c b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
index 3a26419..dfc99b5 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.c
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
@@ -36,48 +36,55 @@
 #include <i915_drm.h>
 
 static void
-intel_batchbuffer_reset(struct brw_context *brw);
+intel_batchbuffer_reset(struct intel_batchbuffer *batch, dri_bufmgr *bufmgr,
+                        bool has_llc);
 
 void
-intel_batchbuffer_init(struct brw_context *brw)
+intel_batchbuffer_init(struct intel_batchbuffer *batch, dri_bufmgr *bufmgr,
+                       bool has_llc)
 {
-   intel_batchbuffer_reset(brw);
+   intel_batchbuffer_reset(batch, bufmgr, has_llc);
 
-   if (!brw->has_llc) {
-      brw->batch.cpu_map = malloc(BATCH_SZ);
-      brw->batch.map = brw->batch.cpu_map;
-      brw->batch.map_next = brw->batch.cpu_map;
+   if (!has_llc) {
+      batch->cpu_map = malloc(BATCH_SZ);
+      batch->map = batch->cpu_map;
+      batch->map_next = batch->cpu_map;
    }
 }
 
 static void
-intel_batchbuffer_reset(struct brw_context *brw)
+intel_batchbuffer_reset(struct intel_batchbuffer *batch, dri_bufmgr *bufmgr,
+                        bool has_llc)
 {
-   if (brw->batch.last_bo != NULL) {
-      drm_intel_bo_unreference(brw->batch.last_bo);
-      brw->batch.last_bo = NULL;
+   if (batch->last_bo != NULL) {
+      drm_intel_bo_unreference(batch->last_bo);
+      batch->last_bo = NULL;
    }
-   brw->batch.last_bo = brw->batch.bo;
+   batch->last_bo = batch->bo;
 
-   brw_render_cache_set_clear(brw);
-
-   brw->batch.bo = drm_intel_bo_alloc(brw->bufmgr, "batchbuffer",
-					BATCH_SZ, 4096);
-   if (brw->has_llc) {
-      drm_intel_bo_map(brw->batch.bo, true);
-      brw->batch.map = brw->batch.bo->virtual;
+   batch->bo = drm_intel_bo_alloc(bufmgr, "batchbuffer", BATCH_SZ, 4096);
+   if (has_llc) {
+      drm_intel_bo_map(batch->bo, true);
+      batch->map = batch->bo->virtual;
    }
-   brw->batch.map_next = brw->batch.map;
+   batch->map_next = batch->map;
 
-   brw->batch.reserved_space = BATCH_RESERVED;
-   brw->batch.state_batch_offset = brw->batch.bo->size;
-   brw->batch.needs_sol_reset = false;
-   brw->batch.state_base_address_emitted = false;
+   batch->reserved_space = BATCH_RESERVED;
+   batch->state_batch_offset = batch->bo->size;
+   batch->needs_sol_reset = false;
+   batch->state_base_address_emitted = false;
 
    /* We don't know what ring the new batch will be sent to until we see the
     * first BEGIN_BATCH or BEGIN_BATCH_BLT.  Mark it as unknown.
     */
-   brw->batch.ring = UNKNOWN_RING;
+   batch->ring = UNKNOWN_RING;
+}
+
+static void
+intel_batchbuffer_reset_and_clear_render_cache(struct brw_context *brw)
+{
+   intel_batchbuffer_reset(&brw->batch, brw->bufmgr, brw->has_llc);
+   brw_render_cache_set_clear(brw);
 }
 
 void
@@ -187,7 +194,7 @@ brw_new_batch(struct brw_context *brw)
 {
    /* Create a new batchbuffer and reset the associated state: */
    drm_intel_gem_bo_clear_relocs(brw->batch.bo, 0);
-   intel_batchbuffer_reset(brw);
+   intel_batchbuffer_reset_and_clear_render_cache(brw);
 
    /* If the kernel supports hardware contexts, then most hardware state is
     * preserved between batches; we only need to re-emit state that is required
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.h b/src/mesa/drivers/dri/i965/intel_batchbuffer.h
index d0ddf75..ee03a44 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.h
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.h
@@ -39,7 +39,8 @@ extern "C" {
 struct intel_batchbuffer;
 
 void intel_batchbuffer_emit_render_ring_prelude(struct brw_context *brw);
-void intel_batchbuffer_init(struct brw_context *brw);
+void intel_batchbuffer_init(struct intel_batchbuffer *batch, dri_bufmgr *bufmgr,
+                            bool has_llc);
 void intel_batchbuffer_free(struct intel_batchbuffer *batch);
 void intel_batchbuffer_save_state(struct brw_context *brw);
 void intel_batchbuffer_reset_to_saved(struct brw_context *brw);
diff --git a/src/mesa/drivers/dri/i965/Makefile.sources b/src/mesa/drivers/dri/i965/Makefile.sources
index 0a7ba1b..9514b9f 100644
--- a/src/mesa/drivers/dri/i965/Makefile.sources
+++ b/src/mesa/drivers/dri/i965/Makefile.sources
@@ -1,6 +1,7 @@
 i965_compiler_FILES = \
 	brw_cfg.cpp \
 	brw_cfg.h \
+	brw_check_register_writes.c \
 	brw_compiler.c \
 	brw_compiler.h \
 	brw_dead_control_flow.cpp \
diff --git a/src/mesa/drivers/dri/i965/brw_check_register_writes.c b/src/mesa/drivers/dri/i965/brw_check_register_writes.c
new file mode 100644
index 0000000..5f7351e
--- /dev/null
+++ b/src/mesa/drivers/dri/i965/brw_check_register_writes.c
@@ -0,0 +1,212 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <intel_bufmgr.h>
+
+#include "brw_context.h"
+#include "intel_screen.h"
+#include "intel_batchbuffer.h"
+#include "brw_defines.h"
+
+#define __BEGIN_BATCH(n) do {                        \
+   ctx->batch->ring = RENDER_RING;                   \
+   uint32_t *___map = ctx->batch->map_next;          \
+   ctx->batch->map_next += (n);
+
+#define __OUT_BATCH(d) *___map++ = (d)
+
+#define __ADVANCE_BATCH()   \
+} while (0)
+
+#define __OUT_RELOC(buf, delta) do { \
+   uint32_t __offset = (___map - ctx->batch->map) * 4;                  \
+   __OUT_BATCH(intel_batchbuffer_reloc(ctx->batch, (buf), __offset,     \
+                                       (I915_GEM_DOMAIN_INSTRUCTION),   \
+                                       (I915_GEM_DOMAIN_INSTRUCTION),   \
+                                       (delta)));                       \
+} while (0)
+
+struct check_register_writes_context {
+   dri_bufmgr *bufmgr;
+   drm_intel_context *hw_ctx;
+   struct intel_batchbuffer *batch;
+   const struct gen_device_info *devinfo;
+};
+
+static void
+emit_mi_flush(struct check_register_writes_context *ctx)
+{
+   assert(ctx->batch->ring == RENDER_RING);
+   assert(ctx->devinfo->gen == 7);
+
+   __BEGIN_BATCH(5);
+   __OUT_BATCH(_3DSTATE_PIPE_CONTROL | (5 - 2));
+   __OUT_BATCH(0); /* flags */
+   __OUT_BATCH(0);
+   __OUT_BATCH(0);
+   __OUT_BATCH(0);
+   __ADVANCE_BATCH();
+}
+
+static int
+do_flush_locked(struct check_register_writes_context *ctx)
+{
+   drm_intel_bo_unmap(ctx->batch->bo);
+   int ret = drm_intel_gem_bo_context_exec(ctx->batch->bo, ctx->hw_ctx,
+                                           4 * USED_BATCH(*(ctx->batch)),
+                                           I915_EXEC_RENDER);
+   return ret;
+}
+
+static int
+batchbuffer_flush(struct check_register_writes_context *ctx)
+{
+   ctx->batch->reserved_space = 0;
+
+   /* Mark the end of the buffer. */
+   intel_batchbuffer_emit_dword(ctx->batch, MI_BATCH_BUFFER_END);
+   if (USED_BATCH(*(ctx->batch)) & 1) {
+      /* Round batchbuffer usage to 2 DWORDs. */
+      intel_batchbuffer_emit_dword(ctx->batch, MI_NOOP);
+   }
+
+   int ret = do_flush_locked(ctx);
+
+   return ret;
+}
+
+static struct check_register_writes_context *
+create_ctx(__DRIscreen *dri_screen)
+{
+   struct check_register_writes_context *ctx =
+      (struct check_register_writes_context *)
+         malloc(sizeof(struct check_register_writes_context));
+
+   struct intel_screen *screen =
+      (struct intel_screen *) dri_screen->driverPrivate;
+   ctx->devinfo = (const struct gen_device_info *) &screen->devinfo;
+
+   ctx->bufmgr = intel_bufmgr_gem_init(dri_screen->fd, BATCH_SZ);
+
+   ctx->hw_ctx = drm_intel_gem_context_create(ctx->bufmgr);
+
+   ctx->batch =
+      (struct intel_batchbuffer *) calloc(1, sizeof(struct intel_batchbuffer));
+
+   intel_batchbuffer_init(ctx->batch, ctx->bufmgr, ctx->devinfo->has_llc);
+
+   return ctx;
+}
+
+static void
+free_ctx(struct check_register_writes_context *ctx)
+{
+   intel_batchbuffer_free(ctx->batch);
+   free(ctx->batch);
+   drm_intel_gem_context_destroy(ctx->hw_ctx);
+   dri_bufmgr_destroy(ctx->bufmgr);
+   free(ctx);
+}
+
+/*
+ * Test if we can use MI_LOAD_REGISTER_MEM from an untrusted batchbuffer.
+ *
+ * Some combinations of hardware and kernel versions allow this feature,
+ * while others don't.  Instead of trying to enumerate every case, just
+ * try and write a register and see if works.
+ */
+int
+brw_can_do_pipelined_register_writes(__DRIscreen *dri_screen)
+{
+   /* gen >= 8 specifically allows these writes. gen <= 6 also
+    * doesn't block them.
+    */
+   struct intel_screen *screen =
+      (struct intel_screen *) dri_screen->driverPrivate;
+   if (screen->devinfo.gen != 7)
+      return true;
+
+   static int result = -1;
+   if (result != -1)
+      return result;
+
+   struct check_register_writes_context *ctx = create_ctx(dri_screen);
+
+   /* We use SO_WRITE_OFFSET0 since you're supposed to write it (unlike the
+    * statistics registers), and we already reset it to zero before using it.
+    */
+   const int reg = GEN7_SO_WRITE_OFFSET(0);
+   const int expected_value = 0x1337d0d0;
+   const int offset = 100;
+
+   /* The register we picked only exists on Gen7+. */
+   assert(screen->devinfo.gen == 7);
+
+   /* Set a value in a BO to a known quantity */
+   uint32_t *data;
+   drm_intel_bo *bo =
+      drm_intel_bo_alloc(ctx->bufmgr, "brw_can_do_pipelined_register_writes",
+                         4096, 4096);
+
+   drm_intel_bo_map(bo, true);
+   data = bo->virtual;
+   data[offset] = 0xffffffff;
+   drm_intel_bo_unmap(bo);
+
+   /* Write the register. */
+   __BEGIN_BATCH(3);
+   __OUT_BATCH(MI_LOAD_REGISTER_IMM | (3 - 2));
+   __OUT_BATCH(reg);
+   __OUT_BATCH(expected_value);
+   __ADVANCE_BATCH();
+
+   emit_mi_flush(ctx);
+
+   /* Save the register's value back to the buffer. */
+   __BEGIN_BATCH(3);
+   __OUT_BATCH(MI_STORE_REGISTER_MEM | (3 - 2));
+   __OUT_BATCH(reg);
+   __OUT_RELOC(bo, offset * sizeof(uint32_t));
+   __ADVANCE_BATCH();
+
+   batchbuffer_flush(ctx);
+
+   /* Check whether the value got written. */
+   drm_intel_bo_map(bo, false);
+   data = bo->virtual;
+   bool success = data[offset] == expected_value;
+   drm_intel_bo_unmap(bo);
+
+   result = success;
+
+   /* Cleanup */
+   drm_intel_bo_unreference(bo);
+   free_ctx(ctx);
+
+   return success;
+}
+
+#undef __BEGIN_BATCH
+#undef __OUT_BATCH
+#undef __OUT_RELOC
+#undef __ADVANCE_BATCH
diff --git a/src/mesa/drivers/dri/i965/brw_context.h b/src/mesa/drivers/dri/i965/brw_context.h
index 3146baf..da469e1 100644
--- a/src/mesa/drivers/dri/i965/brw_context.h
+++ b/src/mesa/drivers/dri/i965/brw_context.h
@@ -1807,6 +1807,9 @@ void brw_query_internal_format(struct gl_context *ctx, GLenum target,
                                GLenum internalFormat, GLenum pname,
                                GLint *params);
 
+/* brw_check_register_writes.c */
+int brw_can_do_pipelined_register_writes(__DRIscreen *dri_screen);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mesa/drivers/dri/i965/intel_extensions.c b/src/mesa/drivers/dri/i965/intel_extensions.c
index bbb7942..5be8f3a 100644
--- a/src/mesa/drivers/dri/i965/intel_extensions.c
+++ b/src/mesa/drivers/dri/i965/intel_extensions.c
@@ -29,77 +29,6 @@
 #include "brw_defines.h"
 #include "intel_batchbuffer.h"
 
-/**
- * Test if we can use MI_LOAD_REGISTER_MEM from an untrusted batchbuffer.
- *
- * Some combinations of hardware and kernel versions allow this feature,
- * while others don't.  Instead of trying to enumerate every case, just
- * try and write a register and see if works.
- */
-static bool
-can_do_pipelined_register_writes(struct brw_context *brw)
-{
-   /**
-    * gen >= 8 specifically allows these writes. gen <= 6 also
-    * doesn't block them.
-    */
-   if (brw->gen != 7)
-      return true;
-
-   static int result = -1;
-   if (result != -1)
-      return result;
-
-   /* We use SO_WRITE_OFFSET0 since you're supposed to write it (unlike the
-    * statistics registers), and we already reset it to zero before using it.
-    */
-   const int reg = GEN7_SO_WRITE_OFFSET(0);
-   const int expected_value = 0x1337d0d0;
-   const int offset = 100;
-
-   /* The register we picked only exists on Gen7+. */
-   assert(brw->gen == 7);
-
-   uint32_t *data;
-   /* Set a value in a BO to a known quantity.  The workaround BO already
-    * exists and doesn't contain anything important, so we may as well use it.
-    */
-   drm_intel_bo_map(brw->workaround_bo, true);
-   data = brw->workaround_bo->virtual;
-   data[offset] = 0xffffffff;
-   drm_intel_bo_unmap(brw->workaround_bo);
-
-   /* Write the register. */
-   BEGIN_BATCH(3);
-   OUT_BATCH(MI_LOAD_REGISTER_IMM | (3 - 2));
-   OUT_BATCH(reg);
-   OUT_BATCH(expected_value);
-   ADVANCE_BATCH();
-
-   brw_emit_mi_flush(brw);
-
-   /* Save the register's value back to the buffer. */
-   BEGIN_BATCH(3);
-   OUT_BATCH(MI_STORE_REGISTER_MEM | (3 - 2));
-   OUT_BATCH(reg);
-   OUT_RELOC(brw->workaround_bo,
-             I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
-             offset * sizeof(uint32_t));
-   ADVANCE_BATCH();
-
-   intel_batchbuffer_flush(brw);
-
-   /* Check whether the value got written. */
-   drm_intel_bo_map(brw->workaround_bo, false);
-   data = brw->workaround_bo->virtual;
-   bool success = data[offset] == expected_value;
-   drm_intel_bo_unmap(brw->workaround_bo);
-
-   result = success;
-
-   return success;
-}
-
 static bool
 can_write_oacontrol(struct brw_context *brw)
 {
@@ -270,6 +199,9 @@ intelInitExtensions(struct gl_context *ctx)
    ctx->Extensions.OES_texture_half_float = true;
    ctx->Extensions.OES_texture_half_float_linear = true;
 
+   brw->can_do_pipelined_register_writes =
+      brw_can_do_pipelined_register_writes(brw->screen->driScrnPriv);
+
    if (brw->gen >= 8)
       ctx->Const.GLSLVersion = 450;
    else if (brw->gen >= 6)
@@ -337,8 +269,6 @@ intelInitExtensions(struct gl_context *ctx)
    }
 
    brw->predicate.supported = false;
-   brw->can_do_pipelined_register_writes =
-      can_do_pipelined_register_writes(brw);
 
    if (brw->gen >= 7) {
       ctx->Extensions.ARB_conservative_depth = true;
diff --git a/src/mesa/drivers/dri/i965/intel_extensions.c b/src/mesa/drivers/dri/i965/intel_extensions.c
index 5be8f3a..6d9c370 100644
--- a/src/mesa/drivers/dri/i965/intel_extensions.c
+++ b/src/mesa/drivers/dri/i965/intel_extensions.c
@@ -204,6 +204,8 @@ intelInitExtensions(struct gl_context *ctx)
 
    if (brw->gen >= 8)
       ctx->Const.GLSLVersion = 450;
+   else if (brw->is_haswell && brw->can_do_pipelined_register_writes)
+      ctx->Const.GLSLVersion = 400;
    else if (brw->gen >= 6)
       ctx->Const.GLSLVersion = 330;
    else
diff --git a/src/mesa/drivers/dri/i965/intel_screen.c b/src/mesa/drivers/dri/i965/intel_screen.c
index d0e3ac6..d484b5d 100644
--- a/src/mesa/drivers/dri/i965/intel_screen.c
+++ b/src/mesa/drivers/dri/i965/intel_screen.c
@@ -1434,7 +1434,8 @@ intel_screen_make_configs(__DRIscreen *dri_screen)
 }
 
 static void
-set_max_gl_versions(struct intel_screen *screen)
+set_max_gl_versions(struct intel_screen *screen,
+                    bool can_do_pipelined_register_writes)
 {
    __DRIscreen *dri_screen = screen->driScrnPriv;
    const bool has_astc = screen->devinfo.gen >= 9;
@@ -1448,7 +1449,8 @@ set_max_gl_versions(struct intel_screen *screen)
       dri_screen->max_gl_es2_version = has_astc ? 32 : 31;
       break;
    case 7:
-      dri_screen->max_gl_core_version = 33;
+      dri_screen->max_gl_core_version = screen->devinfo.is_haswell &&
+         can_do_pipelined_register_writes ? 40 : 33;
       dri_screen->max_gl_compat_version = 30;
       dri_screen->max_gl_es1_version = 11;
       dri_screen->max_gl_es2_version = screen->devinfo.is_haswell ? 31 : 30;
@@ -1653,7 +1655,10 @@ __DRIconfig **intelInitScreen2(__DRIscreen *dri_screen)
       screen->winsys_msaa_samples_override = -1;
    }
 
-   set_max_gl_versions(screen);
+   bool can_do_pipelined_register_writes =
+         brw_can_do_pipelined_register_writes(dri_screen);
+
+   set_max_gl_versions(screen, can_do_pipelined_register_writes);
 
    /* Notification of GPU resets requires hardware contexts and a kernel new
     * enough to support DRM_IOCTL_I915_GET_RESET_STATS.  If the ioctl is
